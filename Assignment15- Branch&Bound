//Develop and implement a solution for the given problem using the Branch and Bound approach.
#include <iostream>
using namespace std;

int n, W;
int weights[20], values[20];
int maxProfit = 0;

// Function to compute upper bound for branch and bound
int bound(int index, int currentWeight, int currentValue) {
    int remainingWeight = W - currentWeight;
    int result = currentValue;

    // Greedily add items fractionally for upper bound
    for (int i = index; i < n; i++) {
        if (weights[i] <= remainingWeight) {
            remainingWeight -= weights[i];
            result += values[i];
        } else {
            result += values[i] * remainingWeight / weights[i];
            break;
        }
    }
    return result;
}

// Recursive function for branch and bound
void knapsack(int index, int currentWeight, int currentValue) {
    if (currentWeight > W) return;       // Exceeds capacity
    if (currentValue > maxProfit) maxProfit = currentValue; // Update best

    for (int i = index; i < n; i++) {
        // Check if promising
        if (bound(i + 1, currentWeight + weights[i], currentValue + values[i]) > maxProfit) {
            knapsack(i + 1, currentWeight + weights[i], currentValue + values[i]);
        }
    }
}

int main() {
    cout << "Enter number of items: ";
    cin >> n;

    cout << "Enter weights of items: ";
    for (int i = 0; i < n; i++) cin >> weights[i];

    cout << "Enter values of items: ";
    for (int i = 0; i < n; i++) cin >> values[i];

    cout << "Enter knapsack capacity: ";
    cin >> W;

    maxProfit = 0;
    knapsack(0, 0, 0);

    cout << "Maximum value possible in knapsack: " << maxProfit << endl;

    return 0;
}
//Input-->Enter number of items: 4
Enter weights of items: 2 3 4 5
Enter values of items: 3 4 5 6
Enter knapsack capacity: 5
//Output-->Maximum value possible in knapsack: 7
